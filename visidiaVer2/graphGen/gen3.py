#!/usr/bin/python3
import random
import sys
#TODO: Implement proper command line arguments
#TODO: Put some minimum seperation between cloned nodes -- Done
#Many nodes.. ~ 1000
#Nodes in some proximity of a particular node must be connected
#Modify visidia source so as to account for labels - can't seem to figure out how

#Possiblity - Generate a file that lists all the nodes that are suppose to be cloned
#	      Later this file is read by the program and changes the labels..

class node:
	def __init__(self,srno,label,x,y):
		self.srno = srno
		self.label = label
		self.x = x
		self.y = y

	def __str__(self):
		return '   node [\n      id {}\n      label "{}"\n      graphics [\n         x {}\n         y {}\n      ]\n   ]'.format(self.srno,self.label,self.x,self.y)

class edge:
	def __init__(self,source,target):
		self.source = source
		self.target = target

	def __str__(self):
		return '   edge [\n      source {}\n      target {}\n      label ""\n      weight 1.0\n   ]'.format(self.source,self.target)


def randomLoc(Xmax,Ymax,Xmin = 0,Ymin = 0):
	return (random.randint(Xmin,Xmax),random.randint(Ymin,Ymax))

def dist(A,B):
	return ( (A.x-B.x)**2 + (A.y-B.y)**2 )**0.5

fileHeader = """graph [
   comment "Generated by ViSiDiA" 
   directed 0"""

def isCompromised(X,Y,X1Comp,Y1Comp,X2Comp,Y2Comp):
	return X>=X1Comp and X<=X2Comp and Y>=Y1Comp and Y<=Y2Comp

def compromiseProbability():
	if random.randint(0,100) >= 95: return True

#How about generating the graph and then selecting the cloned nodes based on seperation?
def genGraph(NoNodes=100,proximity=300,Xmax=1000,Ymax=1000,mat=[[True]],X1Comp=0,Y1Comp=0,X2Comp=1000,Y2Comp=1000):
	nodes = []
	compromisedNodeIds = []
	RXmax = Xmax/len(mat[0]) + 1
	RYmax = Ymax/len(mat) + 1
	for srno in range(NoNodes):
		(x,y) = randomLoc(Xmax,Ymax)
		while mat[int(y/RYmax)][int(x/RXmax)] == False:
			(x,y) = randomLoc(Xmax,Ymax)
		nodes += [node(srno,"N",x,y)]
	edges = []
	for x in range(len(nodes)):
		for y in range(x+1,len(nodes)):
			if dist(nodes[x],nodes[y]) <= proximity:
				edges += [edge(nodes[x].srno,nodes[y].srno)]
	clonedNodeIds = genClones(nodes,proximity*2)
	compromisedNodeIds = compromiseNodes((NoNodes*10)//100,nodes,proximity*2,X1Comp=Xmax//3,Y1Comp=Ymax//3,X2Comp=2*Xmax//3,Y2Comp=2*Ymax//3);
	print(fileHeader)
	for x in nodes: print(x)
	for x in edges: print(x)
	print("]")
	#sys.stderr.write(str(compromisedNodeIds)+"\n")
	#sys.stderr.write(str(clonedNodeIds)+"\n")

def compromiseNodes(noOfNodes,nodes,threshold,X1Comp,Y1Comp,X2Comp,Y2Comp):
	compromisedNodeIds = []
	comprNodes = []
	for x in nodes:
		if noOfNodes == 0:break
		valid = True
		if x.label == "P": continue
		if not(isCompromised(x.x,x.y,X1Comp,Y1Comp,X2Comp,Y2Comp)): continue
		compromisedNodeIds += [x.srno]
		comprNodes += [x]
		x.label = "M"
		noOfNodes -= 1

	return compromisedNodeIds

def genClones(nodes,threshold):
	# Randomly select two clones atleat twice the proximity i.e. threshold = 2*proximity
	n1 = random.randint(0,len(nodes)-1)
	n2 = random.randint(0,len(nodes)-1)
	while dist(nodes[n1],nodes[n2]) < threshold:
		n1 = random.randint(0,len(nodes)-1)
		n2 = random.randint(0,len(nodes)-1)
	nodes[n1].label = "P"
	nodes[n2].label = "P"
	clonedNodes = [nodes[n1].srno,nodes[n2].srno]
	return clonedNodes

if __name__ == '__main__':
	if(len(sys.argv) != 5):print("Usage: {} <NumberOfNodes> <Proximity> <MaximumX> <MaximumY> ".format(sys.argv[0]))
	else: 
		args = [int(sys.argv[x]) for x in range(1,5)]
		rows,cols = [int(x) for x in input().strip().split()]
		mat = []
		for x in range(rows):
			mat += [list(input().strip())]

		for x in range(rows):
			for y in range(cols):
				if mat[x][y] == '#':
					mat[x][y] = True
				else:
					mat[x][y] = False
		genGraph(args[0],args[1],args[2],args[3],mat)


